const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);

// --- Настройки проекта ---
let placedObjects = []; // Массив для хранения размещенных объектов

// --- Размеры площадки ---
let playgroundWidth = 10; // Ширина площадки в метрах (по умолчанию)
let playgroundLength = 10; // Длина площадки в метрах (по умолчанию)

// --- Фон ---
var skybox = BABYLON.MeshBuilder.CreateBox("cityBox", {size:1000.0}, scene);
var skyboxMaterial = new BABYLON.StandardMaterial("cityBox", scene);
skyboxMaterial.backFaceCulling = false;
skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("textures/citybox/citybox", scene);
skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
skybox.material = skyboxMaterial;

// --- Камера с OrbitControls (по аналогии с shed_designer) ---
const camera = new BABYLON.ArcRotateCamera(
    "camera",
    0,           // Поворот вокруг оси Y
    1.3,         // Наклон (около 1.57 = строго сверху)
    15,          // Радиус (расстояние до центра)
    new BABYLON.Vector3(0, 0, 0),
    scene
);
camera.attachControl(canvas, true);
camera.upperBetaLimit = Math.PI / 2.2;
camera.lowerRadiusLimit = 5;  // Минимальное расстояние до центра
camera.upperRadiusLimit = 50; // Максимальное расстояние до центра

// Позволяет более плавно управлять камерой
camera.inertia = 0.7;
camera.wheelPrecision = 100; // Чувствительность зума колесиком мыши
camera.panningSensibility = 100; // Чувствительность панорамирования

// --- Свет ---
const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0), scene);

// --- Поверхность (playground) ---
// Глобальная переменная ground будет содержать контейнер загруженной модели playground
let ground = null;
let groundMesh = null;

BABYLON.SceneLoader.ImportMesh("", "models/", "playground.glb", scene, function (newMeshes) {
    if (!newMeshes || newMeshes.length === 0) return;
    
    // Получаем корневой контейнер (если он есть) или первую мешу
    const playground = newMeshes[0].parent || newMeshes[0];
    
    // Настройка модели playground
    playground.position = new BABYLON.Vector3(0, 0, 0);
    playground.rotationQuaternion = null; // Сбрасываем поворот из glTF
    playground.scaling = new BABYLON.Vector3(1, 1, 1);
    
    ground = playground;
    groundMesh = newMeshes[0]; // Сохраняем первую мешу для совместимости

    // Обновляем текстовый статус в правой панели
    const statusElement = document.getElementById("playgroundStatus");
    if (statusElement) {
        statusElement.textContent = `Площадка: ${playgroundWidth}м × ${playgroundLength}м`;
    }
    
    // Обновляем HTML-метки размеров
    document.getElementById("widthLabel").textContent = `${playgroundWidth}м`;
    document.getElementById("lengthLabel").textContent = `${playgroundLength}м`;
});

// Функция для создания новой площадки с заданными размерами (совместимости ради)
function createPlayground(width, length) {
    // Обновляем текстовый статус в правой панели
    const statusElement = document.getElementById("playgroundStatus");
    if (statusElement) {
        statusElement.textContent = `Площадка: ${width}м × ${length}м`;
    }
    
    // Обновляем HTML-метки размеров
    document.getElementById("widthLabel").textContent = `${width}м`;
    document.getElementById("lengthLabel").textContent = `${length}м`;
    
    // Если есть ground, масштабируем его
    if (ground) {
        ground.scaling = new BABYLON.Vector3(width/10, 1, length/10);
    }
    
    return ground;
}

// Функция для создания скриншота сцены с анимацией
function takeScreenshot() {
    // Создаем эффект вспышки перед скриншотом
    const flashOverlay = document.createElement('div');
    flashOverlay.style.position = 'fixed';
    flashOverlay.style.top = '0';
    flashOverlay.style.left = '0';
    flashOverlay.style.width = '100%';
    flashOverlay.style.height = '100%';
    flashOverlay.style.backgroundColor = 'white';
    flashOverlay.style.opacity = '0';
    flashOverlay.style.transition = 'opacity 0.2s ease-in-out';
    flashOverlay.style.pointerEvents = 'none';
    flashOverlay.style.zIndex = '9999';
    document.body.appendChild(flashOverlay);
    
    // Делаем вспышку и скрываем ее
    setTimeout(() => {
        flashOverlay.style.opacity = '0.5';
        
        // Создаем скриншот canvas после эффекта вспышки
        setTimeout(() => {
            BABYLON.Tools.CreateScreenshot(engine, camera, { precision: 1 }, function(data) {
                // Убираем эффект вспышки
                flashOverlay.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(flashOverlay);
                }, 200);
                
                // Создаем ссылку для скачивания
                const downloadLink = document.createElement('a');
                downloadLink.href = data;
                
                // Создаем имя файла с датой и временем
                const date = new Date();
                const fileName = `playground_${date.getFullYear()}-${(date.getMonth()+1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}_${date.getHours().toString().padStart(2, '0')}-${date.getMinutes().toString().padStart(2, '0')}.png`;
                
                downloadLink.download = fileName;
                
                // Эмулируем клик для запуска скачивания
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);
                
                // Показываем уведомление
                showNotification("Фотография успешно сохранена!", false);
            });
        }, 100);
    }, 50);
}

// --- Добавляем обработчик событий для формы в правой панели ---
document.addEventListener("DOMContentLoaded", () => {
    // Добавляем обработчик для кнопки создания скриншота
    document.getElementById("saveScreenshot").addEventListener("click", takeScreenshot);
    
    // Устанавливаем начальные значения в поля формы
    document.getElementById("playgroundWidth").value = playgroundWidth;
    document.getElementById("playgroundLength").value = playgroundLength;
    
    // Обновляем статус площадки при загрузке
    const statusElement = document.getElementById("playgroundStatus");
    if (statusElement) {
        statusElement.textContent = `Площадка: ${playgroundWidth}м × ${playgroundLength}м`;
    }
    
    // Добавляем обработчики для полей ввода размеров, которые будут обновлять предпросмотр
    document.getElementById("playgroundWidth").addEventListener("input", (e) => {
        const value = parseFloat(e.target.value) || playgroundWidth;
        document.getElementById("widthLabel").textContent = `${value}м`;
    });
    
    document.getElementById("playgroundLength").addEventListener("input", (e) => {
        const value = parseFloat(e.target.value) || playgroundLength;
        document.getElementById("lengthLabel").textContent = `${value}м`;
    });
    
    // Добавляем обработчик для кнопки "Применить"
    document.getElementById("applySettings").addEventListener("click", () => {
        const newWidth = parseFloat(document.getElementById("playgroundWidth").value);
        const newLength = parseFloat(document.getElementById("playgroundLength").value);
        
        if (newWidth >= 5 && newWidth <= 50 && newLength >= 5 && newLength <= 50) {
            const oldWidth = playgroundWidth;
            const oldLength = playgroundLength;
            
            // Применяем анимацию плавного изменения размеров
            const startTime = Date.now();
            const duration = 1000; // 1 секунда для анимации
            
            const animateResize = function() {
                const elapsedTime = Date.now() - startTime;
                const progress = Math.min(elapsedTime / duration, 1);
                
                // Используем функцию плавной анимации
                const easeProgress = easeInOutCubic(progress);
                
                // Вычисляем текущие размеры на основе прогресса анимации
                const currentWidth = oldWidth + (newWidth - oldWidth) * easeProgress;
                const currentLength = oldLength + (newLength - oldLength) * easeProgress;
                
                // Устанавливаем новые размеры площадки
                if (progress < 1) {
                    // Если анимация не завершена, обновляем mesh
                    if (groundMesh) {
                        groundMesh.scaling.x = currentWidth / oldWidth;
                        groundMesh.scaling.z = currentLength / oldLength;
                    }
                    
                    // Обновляем метки
                    document.getElementById("widthLabel").textContent = `${currentWidth.toFixed(1)}м`;
                    document.getElementById("lengthLabel").textContent = `${currentLength.toFixed(1)}м`;
                    
                    // Продолжаем анимацию
                    requestAnimationFrame(animateResize);
                } else {
                    // Анимация завершена, устанавливаем точные значения
                    playgroundWidth = newWidth;
                    playgroundLength = newLength;
                    
                    // Обновляем площадку
                    ground = createPlayground(playgroundWidth, playgroundLength);
                    
                    // Проверка позиций объектов отключена
                    
                    // Показываем уведомление
                    showNotification("Размеры площадки успешно обновлены", false);
                }
            };
            
            // Функция для плавной анимации
            function easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }
            
            // Запускаем анимацию
            animateResize();
        } else {
            // Показываем предупреждение, если размеры некорректны
            showNotification("Размеры должны быть в диапазоне от 5 до 50 метров", true);
        }
    });
    
    // Добавляем обработчик для кнопки сброса вида
    document.getElementById("resetView").addEventListener("click", () => {
        // Параметры для анимации
        const targetAlpha = 0; // Целевой поворот вокруг оси Y
        const targetBeta = 1.3; // Целевой наклон
        const targetRadius = playgroundWidth > playgroundLength ? 
                           playgroundWidth * 1.5 : playgroundLength * 1.5; // Целевое расстояние
        const targetPosition = BABYLON.Vector3.Zero(); // Целевая точка камеры
        
        // Создаем анимацию для плавного перемещения камеры
        const startTime = Date.now();
        const duration = 1000; // 1 секунда для анимации
        
        // Сохраняем начальные значения
        const startAlpha = camera.alpha;
        const startBeta = camera.beta;
        const startRadius = camera.radius;
        const startTarget = camera.target.clone();
        
        // Функция анимации
        const animateCamera = function() {
            const elapsedTime = Date.now() - startTime;
            const progress = Math.min(elapsedTime / duration, 1);
            
            // Используем функцию плавной анимации
            const easeProgress = easeInOutCubic(progress);
            
            // Обновляем параметры камеры с учетом прогресса анимации
            camera.alpha = startAlpha + (targetAlpha - startAlpha) * easeProgress;
            camera.beta = startBeta + (targetBeta - startBeta) * easeProgress;
            camera.radius = startRadius + (targetRadius - startRadius) * easeProgress;
            
            // Обновляем целевую точку камеры
            const newTarget = new BABYLON.Vector3(
                startTarget.x + (targetPosition.x - startTarget.x) * easeProgress,
                startTarget.y + (targetPosition.y - startTarget.y) * easeProgress,
                startTarget.z + (targetPosition.z - startTarget.z) * easeProgress
            );
            camera.target = newTarget;
            
            // Продолжаем анимацию, если она не завершена
            if (progress < 1) {
                requestAnimationFrame(animateCamera);
            } else {
                // Анимация завершена, показываем уведомление
                showNotification("Вид камеры сброшен", false);
            }
        };
        
        // Функция для плавной анимации
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        // Запускаем анимацию
        animateCamera();
    });
});

// --- Цены элементов ---
const elementPrices = {
    "0001.glb": 8000,
    "242.glb": 7500,
    "0502.glb": 12000,
    "0519.glb": 11000,
    "3540.glb": 9500,
    "4209.glb": 13000,
    "Каркас качелей-балансира -Тайга-.stl": 14000,
    "lgd_3.glb": 11000,
    "lgk_11.glb": 6000,
    "lgk_314.glb": 10000,
    "MG0001 2024-09 R2 Модель.glb": 25000,
    "MG0001.stl": 20000,
    "msk_105.glb": 4000,
    "msk_201.glb": 15000,
};

let totalPrice = 0;

const modelSizes = {
    "0001.glb": 2,
    "242.glb": 2,
    "0502.glb": 2,
    "0519.glb": 2,
    "3540.glb": 3,
    "4209.glb": 4,
    "Каркас качелей-балансира -Тайга-.stl": 2.5,
    "lgd_3.glb": 2,
    "lgk_11.glb": 0.1,
    "lgk_314.glb": 2,
    "MG0001 2024-09 R2 Модель.glb": 10,
    "MG0001.stl": 10,
    "msk_105.glb": 3,
    "msk_201.glb": 3,
    "201.fbx":3,
};

// Функция для получения границ объекта
function getObjectBounds(object) {
    const boundingInfo = object.getHierarchyBoundingVectors(true);
    const min = boundingInfo.min;
    const max = boundingInfo.max;
    
    // Вычисляем центр объекта
    const center = new BABYLON.Vector3(
        (min.x + max.x) / 2 + object.position.x,
        0,
        (min.z + max.z) / 2 + object.position.z
    );
    
    // Вычисляем радиус (половина максимального размера)
    const radius = Math.max(
        (max.x - min.x) / 2,
        (max.z - min.z) / 2
    );
    
    return { center, radius };
}

// Функция для проверки, находится ли объект в пределах площадки
// Эта функция теперь всегда возвращает true, так как требуется убрать проверку на выход за границы
function isWithinPlayground(object) {
    return true;
}

// Функция для подсветки границ площадки
// Функция теперь ничего не делает, так как визуальная индикация некорректного размещения удалена
let boundaryLines = [];
function highlightPlaygroundBoundary(show) {
    // Функционал подсветки удален
    return;
}

// Функция для сохранения исходной позиции объекта
// Оставлена для совместимости, но не используется для автовозврата
function saveInitialPosition(object) {
    // Функционал сохранения исходной позиции отключен
}

// Функция для возврата объекта на исходную позицию
// Оставлена для совместимости, но больше не используется
function resetToInitialPosition(object) {
    // Функционал возврата на исходную позицию отключен
}

// Функция для проверки объекта
// Теперь не выполняет проверки, просто заглушка для совместимости
function checkAndHighlightObject(object) {
    // Теперь объект всегда считается размещенным корректно
    updatePositionStatus(true);
    
    // Удаляем информацию о нарушениях в объекте
    if (object) {
        object.hasPositionError = false;
    }
    
    return true;
}

// Функция для обновления статуса позиции в интерфейсе
function updatePositionStatus(withinPlayground) {
    const statusElement = document.getElementById("positionStatus");
    
    if (!statusElement) return;
    
    // Всегда показываем "Позиция корректна", так как проверка убрана
    statusElement.textContent = "Позиция корректна";
    statusElement.className = "valid-position";
}

// Функция для проверки всех объектов на площадке
function checkAllObjectsPositions() {
    for (let object of placedObjects) {
        checkAndHighlightObject(object);
    }
}

// Функция для показа уведомления
function showNotification(message, isWarning = true) {
    const notification = document.getElementById('notification');
    const notificationMessage = document.querySelector('.notification-message');
    
    if (notification && notificationMessage) {
        notificationMessage.textContent = message;
        notification.className = isWarning ? 'notification warning' : 'notification info';
        notification.classList.remove('hidden');
        
        // Автоматически скрываем уведомление через 3 секунды
        setTimeout(() => {
            notification.classList.add('hidden');
        }, 3000);
        
        // Обработчик для кнопки закрытия
        const closeButton = notification.querySelector('.notification-close');
        if (closeButton) {
            closeButton.onclick = function() {
                notification.classList.add('hidden');
            };
        }
    }
}

// --- Обработчик начала перетаскивания для загрузки модели ---
document.querySelectorAll(".item").forEach(item => {
    item.addEventListener("dragstart", event => {
        const model = event.target.closest(".item").getAttribute("data-model");
        console.log("Drag started:", model);
        event.dataTransfer.setData("model", model);
    });
});

// --- Остановка поведения по умолчанию для drop ---
canvas.addEventListener("dragover", event => event.preventDefault());

// Генератор уникальных идентификаторов
let nextObjectId = 1;
function generateObjectId() {
    return `object_${nextObjectId++}`;
}

// --- Обработка события drop для загрузки модели ---
canvas.addEventListener("drop", event => {
    event.preventDefault();
    const modelName = event.dataTransfer.getData("model");
    
    // Получаем координаты точки на площадке, куда пользователь "уронил" объект
    // Проверяем, что клик был по площадке
    const pickResult = scene.pick(
        event.clientX, 
        event.clientY, 
        mesh => groundMesh && (mesh === groundMesh || mesh.isDescendantOf(ground))
    );

    if (modelName) {
        BABYLON.SceneLoader.ImportMesh("", "models/", modelName, scene, function (newMeshes) {
            if (!newMeshes || newMeshes.length === 0) {
                console.error("Ошибка: модель не загружена", modelName);
                return;
            }

            // Создаём контейнер для импортированных мешей
            const container = new BABYLON.TransformNode(`modelContainer_${modelName}_${generateObjectId()}`, scene);
            // Добавляем уникальный id для отслеживания конфликтов
            container.id = generateObjectId();
            newMeshes.forEach(mesh => {
                mesh.parent = container;
            });

            // При необходимости поворачиваем конкретные модели
            if (modelName === "MG0001 2024-09 R2 Модель.glb") {
                container.rotation.x = Math.PI / 2;
            }
            if (modelName === "0519.glb") {
                container.rotation.x = Math.PI / -2;
            }
            if (modelName === "0001.glb") {
                container.rotation.x = Math.PI / -2;
            }

            // Устанавливаем контейнер в позицию броска на площадке
            if (pickResult && pickResult.hit && pickResult.pickedPoint) {
                container.position = pickResult.pickedPoint;
            } else {
                // Если площадка не попала под курсор, ставим объект в центр площадки
                container.position = new BABYLON.Vector3(0, 0, 0);
                showNotification("Объект помещен в центр площадки", false);
            }
                
            // Вычисляем bounding box
            let boundingVectors = container.getHierarchyBoundingVectors();
            let size = boundingVectors.max.subtract(boundingVectors.min);
            let maxDimension = Math.max(size.x, size.y, size.z);

            // Определяем стандартный размер для модели из словаря
            let standardSize = modelSizes[modelName] || 1;

            // Масштабируем так, чтобы максимальная размерность стала равна standardSize
            let scaleFactor = standardSize / maxDimension;
            container.scaling = new BABYLON.Vector3(scaleFactor, scaleFactor, scaleFactor);

            // Выравниваем нижнюю грань по Y=0
            boundingVectors = container.getHierarchyBoundingVectors();
            const minY = boundingVectors.min.y;
            container.position.y -= minY;
            
            // Добавляем объект в массив размещенных объектов
            placedObjects.push(container);
            
            // Проверяем и подсвечиваем объект
            checkAndHighlightObject(container);

            // Обновляем общую стоимость
            const price = elementPrices[modelName] || 0;
            totalPrice += price;
            document.getElementById("totalPrice").textContent = totalPrice.toLocaleString();

            // Добавляем информацию в таблицу с кнопкой удаления
            const tableBody = document.querySelector("#elementsTable tbody");
            const row = document.createElement("tr");
            row.innerHTML = `<td>${modelName}</td>
                             <td>${price.toLocaleString()} ₽</td>
                             <td><button class="delete-button" style="cursor:pointer;">🗑️</button></td>`;
            tableBody.appendChild(row);

            // Сохраняем ссылку на контейнер и стоимость в строке
            row.container = container;
            row.price = price;

            // Обработчик удаления элемента
            row.querySelector(".delete-button").addEventListener("click", () => {
                if (row.container) {
                    // Удаляем объект из массива размещенных объектов
                    const index = placedObjects.indexOf(row.container);
                    if (index > -1) {
                        placedObjects.splice(index, 1);
                    }
                    
                    row.container.dispose();
                }
                totalPrice -= row.price;
                document.getElementById("totalPrice").textContent = totalPrice.toLocaleString();
                row.remove();
                
                // Перепроверяем все объекты
                checkAllObjectsPositions();
            });
        });
    }
});

// --- Отключаем стандартное контекстное меню (правый клик) ---
canvas.addEventListener("contextmenu", event => event.preventDefault());

// --- Глобальные переменные для управления манипуляциями с объектами ---
let selectedMesh = null;
let isDragging = false;
let isRotating = false;
let dragOffset = BABYLON.Vector3.Zero();
let initialRotationY = 0;
let initialPointerX = 0;

// Обработка кликов и движения мыши
scene.onPointerObservable.add(pointerInfo => {
    const event = pointerInfo.event;
    
    if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN) {
        const pickInfo = pointerInfo.pickInfo;
        if (pickInfo && pickInfo.hit && pickInfo.pickedMesh) {
            // Если клик по playground или по его дочерним объектам – не выбираем объект
            if (groundMesh && (pickInfo.pickedMesh === groundMesh || pickInfo.pickedMesh.isDescendantOf(ground))) {
                selectedMesh = null;
                return;
            }
            // Выбираем корневой контейнер объекта
            selectedMesh = pickInfo.pickedMesh.parent || pickInfo.pickedMesh;
            
            // Сохраняем исходную позицию перед началом движения
            saveInitialPosition(selectedMesh);
            
            // Отключаем управление камерой, чтобы не мешало перемещать/вращать объект
            camera.detachControl(canvas);

            // Левый клик – начинаем перетаскивание
            if (event.button === 0) {
                isDragging = true;
                dragOffset = selectedMesh.position.subtract(pickInfo.pickedPoint);
            }
            // Правый клик – начинаем вращение
            else if (event.button === 2) {
                isRotating = true;
                initialRotationY = selectedMesh.rotation.y;
                initialPointerX = event.clientX;
            }
        }
    }
    else if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERMOVE) {
        // Перемещение объекта
        if (isDragging && selectedMesh) {
            // Выбираем точку на поверхности playground (учитываем все дочерние объекты)
            const pickResult = scene.pick(
                scene.pointerX,
                scene.pointerY,
                mesh => groundMesh && (mesh === groundMesh || mesh.isDescendantOf(ground))
            );
            if (pickResult && pickResult.hit && pickResult.pickedPoint) {
                let newPos = pickResult.pickedPoint.add(dragOffset);
                newPos.y = 0;
                selectedMesh.position = newPos;
                
                // Выравнивание нижней грани объекта по Y=0
                let boundingVectors = selectedMesh.getHierarchyBoundingVectors();
                const minY = boundingVectors.min.y;
                selectedMesh.position.y -= minY;
                
                // Проверяем и подсвечиваем объект при перемещении
                checkAndHighlightObject(selectedMesh);
            }
        }
        // Вращение объекта
        else if (isRotating && selectedMesh) {
            const deltaX = event.clientX - initialPointerX;
            selectedMesh.rotation.y = initialRotationY + deltaX * 0.01;
            
            // Проверяем и подсвечиваем объект при вращении
            checkAndHighlightObject(selectedMesh);
        }
    }
else if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERUP) {
        // Завершаем перемещение/вращение
        if (isDragging || isRotating) {
            camera.attachControl(canvas, true);
            
            // Проверка на выход за границы и автовозврат удалены
            
            // Проверяем все объекты после взаимодействия (оставляем для совместимости)
            checkAllObjectsPositions();
        }
        isDragging = false;
        isRotating = false;
        selectedMesh = null;
    }
});

engine.runRenderLoop(() => scene.render());
window.addEventListener("resize", () => engine.resize());